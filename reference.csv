array,string,stack,queue,linked,tree,graph,hash,heap
0,"Normally, an array is a collection of similar type of elements which has contiguous memory location.Java array is an object which contains elements of a similar data type. Additionally, The elements of an array are stored in a contiguous memory location. It is a data structure where we store similar elements. We can store only a fixed set of elements in a Java array.Array in Java is index-based, the first element of the array is stored at the 0th index, 2nd element is stored on 1st index and so on. Unlike C/C++, we can get the length of the array using the length member. In C/C++, we need to use the sizeof operator. In Java, array is an object of a dynamically generated class. Java array inherits the Object class, and implements the Serializable as well as Cloneable interfaces. We can store primitive values or objects in an array in Java. Like C/C++, we can also create single dimentional or multidimentional arrays in Java.Moreover, Java provides the feature of anonymous arrays which is not available in C/C++.
Code Optimization: It makes the code optimized, we can retrieve or sort the data efficiently.
Random access: We can get any data located at an index position.

Size Limit: We can store only the fixed size of elements in the array. It doesn't grow its size at runtime. To solve this problem, collection framework is used in Java which grows automatically.
There are two types of array.
Single Dimensional Array
Multidimensional Array
Single Dimensional Array in JavaSyntax to Declare an Array in JavaInstantiation of an Array in JavaLet's see the simple example of java array, where we are going to declare, instantiate, initialize and traverse an array.Output:Declaration, Instantiation and Initialization of Java ArrayWe can declare, instantiate and initialize the java array together by:Let's see the simple example to print this array.Output:For-each Loop for Java ArrayWe can also print the Java array using for-each loop. The Java for-each loop prints the array elements one by one. It holds an array element in a variable, then executes the body of the loop.The syntax of the for-each loop is given below:Let us see the example of print the elements of Java array using the for-each loop.Output:Passing Array to a Method in JavaWe can pass the java array to method so that we can reuse the same logic on any array.Let's see the simple example to get the minimum number of an array using a method.Output:Anonymous Array in JavaJava supports the feature of an anonymous array, so you don't need to declare the array while passing an array to the method.Output:Returning Array from the MethodWe can also return an array from the method in Java.Output:ArrayIndexOutOfBoundsExceptionThe Java Virtual Machine (JVM) throws an ArrayIndexOutOfBoundsException if length of the array in negative, equal to the array size or greater than the array size while traversing the array.Output:Multidimensional Array in JavaIn such case, data is stored in row and column based index (also known as matrix form).Syntax to Declare Multidimensional Array in JavaExample to instantiate Multidimensional Array in JavaExample to initialize Multidimensional Array in JavaLet's see the simple example to declare, instantiate, initialize and print the 2Dimensional array.Output:Jagged Array in JavaIf we are creating odd number of columns in a 2D array, it is known as a jagged array. In other words, it is an array of arrays with different number of columns.Output:What is the class name of Java array?In Java, an array is an object. For array object, a proxy class is created whose name can be obtained by getClass().getName() method on the object.Output:Copying a Java ArrayWe can copy an array to another by the arraycopy() method of System class.Syntax of arraycopy methodOutput:Cloning an Array in JavaSince, Java array implements the Cloneable interface, we can create the clone of the Java array. If we create the clone of a single-dimensional array, it creates the deep copy of the Java array. It means, it will copy the actual value. But, if we create the clone of a multidimensional array, it creates the shallow copy of the Java array which means it copies the references.Output:Addition of 2 Matrices in JavaLet's see a simple example that adds two matrices.Output:Multiplication of 2 Matrices in JavaIn the case of matrix multiplication, a one-row element of the first matrix is multiplied by all the columns of the second matrix which can be understood by the image given below.Let's see a simple example to multiply two matrices of 3 rows and 3 columns.Output:1) Java Program to copy all elements of one array into another array2) Java Program to find the frequency of each element in the array3) Java Program to left rotate the elements of an array4) Java Program to print the duplicate elements of an array5) Java Program to print the elements of an array6) Java Program to print the elements of an array in reverse order7) Java Program to print the elements of an array present on even position8) Java Program to print the elements of an array present on odd position9) Java Program to print the largest element in an array10) Java Program to print the smallest element in an array11) Java Program to print the number of elements present in an array12) Java Program to print the sum of all the items of the array13) Java Program to right rotate the elements of an array14) Java Program to sort the elements of an array in ascending order15) Java Program to sort the elements of an array in descending order16) Find 3rd Largest Number in an Array17) Find 2nd Largest Number in an Array18) Find Largest Number in an Array19) Find 2nd Smallest Number in an Array20) Find Smallest Number in an Array21) Remove Duplicate Element in an Array22) Add Two Matrices23) Multiply Two Matrices24) Print Odd and Even Number from an Array25) Transpose matrix26) Java Program to subtract the two matrices27) Java Program to determine whether a given matrix is an identity matrix28) Java Program to determine whether a given matrix is a sparse matrix29) Java Program to determine whether two matrices are equal30) Java Program to display the lower triangular matrix31) Java Program to display the upper triangular matrix32) Java Program to find the frequency of odd & even numbers in the given matrix33) Java Program to find the product of two matrices34) Java Program to find the sum of each row and each column of a matrix35) Java Program to find the transpose of a given matrix","In Java, string is basically an object that represents sequence of char values. An array of characters works same as Java string. For example:is same as:Java String class provides a lot of methods to perform operations on strings such as compare(), concat(), equals(), split(), length(), replace(), compareTo(), intern(), substring() etc.The java.lang.String class implements Serializable, Comparable and CharSequence interfaces.CharSequence InterfaceThe CharSequence interface is used to represent the sequence of characters. String, StringBuffer and StringBuilder classes implement it. It means, we can create strings in Java by using these three classes.The Java String is immutable which means it cannot be changed. Whenever we change any string, a new instance is created. For mutable strings, you can use StringBuffer and StringBuilder classes.We will discuss immutable string later. Let's first understand what String in Java is and how to create the String object.Generally, String is a sequence of characters. But in Java, string is an object that represents a sequence of characters. The java.lang.String class is used to create a string object.There are two ways to create String object:Java String literal is created by using double quotes. For Example:Each time you create a string literal, the JVM checks the ""string constant pool"" first. If the string already exists in the pool, a reference to the pooled instance is returned. If the string doesn't exist in the pool, a new string instance is created and placed in the pool. For example:In the above example, only one object will be created. Firstly, JVM will not find any string object with the value ""Welcome"" in string constant pool that is why it will create a new object. After that it will find the string with the value ""Welcome"" in the pool, it will not create a new object but will return the reference to the same instance.To make Java more memory efficient (because no new objects are created if it exists already in the string constant pool).In such case, JVM will create a new string object in normal (non-pool) heap memory, and the literal ""Welcome"" will be placed in the string constant pool. The variable s will refer to the object in a heap (non-pool).StringExample.javaOutput:The above code, converts a char array into a String object. And displays the String objects s1, s2, and s3 on console using println() method.The java.lang.String class provides many useful methods to perform operations on sequence of char values.","A Stack is a linear data structure that follows the LIFO (Last-In-First-Out) principle. Stack has one end, whereas the Queue has two ends (front and rear). It contains only one pointer top pointer pointing to the topmost element of the stack. Whenever an element is added in the stack, it is added on the top of the stack, and the element can be deleted only from the stack. In other words, a stack can be defined as a container in which insertion and deletion can be done from the one end known as the top of the stack.
It is called as stack because it behaves like a real-world stack, piles of books, etc.
A Stack is an abstract data type with a pre-defined capacity, which means that it can store the elements of a limited size.
It is a data structure that follows some order to insert and delete the elements, and that order can be LIFO or FILO.
Stack works on the LIFO pattern. As we can observe in the below figure there are five memory blocks in the stack; therefore, the size of the stack is 5.Suppose we want to store the elements in a stack and let's assume that stack is empty. We have taken the stack of size 5 as shown below in which we are pushing the elements one by one until the stack becomes full.Since our stack is full as the size of the stack is 5. In the above cases, we can observe that it goes from the top to the bottom when we were entering the new element in the stack. The stack gets filled up from the bottom to the top.When we perform the delete operation on the stack, there is only one way for entry and exit as the other end is closed. It follows the LIFO pattern, which means that the value entered first will be removed last. In the above case, the value 5 is entered first, so it will be removed only after the deletion of all the other elements.The following are some common operations implemented on the stack:
push(): When we insert an element in a stack then the operation is known as a push. If the stack is full then the overflow condition occurs.
pop(): When we delete an element from the stack, the operation is known as a pop. If the stack is empty means that no element exists in the stack, this state is known as an underflow state.
isEmpty(): It determines whether the stack is empty or not.
isFull(): It determines whether the stack is full or not.'
peek(): It returns the element at the given position.
count(): It returns the total number of elements available in a stack.
change(): It changes the element at the given position.
display(): It prints all the elements available in the stack.
The steps involved in the PUSH operation is given below:
Before inserting an element in a stack, we check whether the stack is full.
If we try to insert the element in a stack, and the stack is full, then the overflow condition occurs.
When we initialize a stack, we set the value of top as -1 to check that the stack is empty.
When the new element is pushed in a stack, first, the value of the top gets incremented, i.e., top=top+1, and the element will be placed at the new position of the top.
The elements will be inserted until we reach the max size of the stack.
The steps involved in the POP operation is given below:
Before deleting the element from the stack, we check whether the stack is empty.
If we try to delete the element from the empty stack, then the underflow condition occurs.
If the stack is not empty, we first access the element which is pointed by the top 
Once the pop operation is performed, the top is decremented by 1, i.e., top=top-1.
The following are the applications of the stack:
Balancing of symbols: Stack is used for balancing a symbol. For example, we have the following program:
As we know, each program has an opening and closing braces; when the opening braces come, we push the braces in a stack, and when the closing braces appear, we pop the opening braces from the stack. Therefore, the net value comes out to be zero. If any symbol is left in the stack, it means that some syntax occurs in a program.
String reversal: Stack is also used for reversing a string. For example, we want to reverse a ""javaTpoint"" string, so we can achieve this with the help of a stack.
First, we push all the characters of the string in a stack until we reach the null character.
After pushing all the characters, we start taking out the character one by one until we reach the bottom of the stack.
UNDO/REDO: It can also be used for performing UNDO/REDO operations. For example, we have an editor in which we write 'a', then 'b', and then 'c'; therefore, the text written in an editor is abc. So, there are three states, a, ab, and abc, which are stored in a stack. There would be two stacks in which one stack shows UNDO state, and the other shows REDO state.
If we want to perform UNDO operation, and want to achieve 'ab' state, then we implement pop operation.
Recursion: The recursion means that the function is calling itself again. To maintain the previous states, the compiler creates a system stack in which all the previous records of the function are maintained.
DFS(Depth First Search): This search is implemented on a Graph, and Graph uses the stack data structure.
Backtracking: Suppose we have to create a path to solve a maze problem. If we are moving in a particular path, and we realize that we come on the wrong way. In order to come at the beginning of the path to create a new path, we have to use the stack data structure.
Expression conversion: Stack can also be used for expression conversion. This is one of the most important applications of stack. The list of the expression conversion is given below:
Infix to prefix
Infix to postfix
Prefix to infix
Prefix to postfix
Postfix to infix
Memory management: The stack manages the memory. The memory is assigned in the contiguous memory blocks. The memory is known as stack memory as all the variables are assigned in a function call stack memory. The memory size assigned to the program is known to the compiler. When the function is created, all its variables are assigned in the stack memory. When the function completed its execution, all the variables assigned in the stack are released.
","1. A queue can be defined as an ordered list which enables insert operations to be performed at one end called REAR and delete operations to be performed at another end called FRONT. 2. Queue is referred to be as First In First Out list. 3. For example, people waiting in line for a rail ticket form a queue. Applications of QueueDue to the fact that queue performs actions on first in first out basis which is quite fair for the ordering of actions. There are various applications of queues discussed as below. Complexity ","
Linked List can be defined as collection of objects called nodes that are randomly stored in the memory.
A node contains two fields i.e. data stored at that particular address and the pointer which contains the address of the next node in the memory. 
The last node of the list contains pointer to the null.
Uses of Linked List
The list is not required to be contiguously present in the memory. The node can reside any where in the memory and linked together to make a list. This achieves optimized utilization of space.
list size is limited to the memory size and doesn't need to be declared in advance.
Empty node can not be present in the linked list.
We can store values of primitive types or objects in the singly linked list.
Why use linked list over array?Till now, we were using array data structure to organize the group of elements that are to be stored individually in the memory. However, Array has several advantages and disadvantages which must be known in order to decide the data structure which will be used throughout the program. Array contains following limitations:Linked list is the data structure which can overcome all the limitations of an array. Using linked list is useful because, Singly linked list or One way chain Singly linked list can be defined as the collection of ordered set of elements. The number of elements may vary according to need of the program. A node in the singly linked list consist of two parts: data part and link part. Data part of the node stores actual information that is to be represented by the node while the link part of the node stores the address of its immediate successor. One way chain or singly linked list can be traversed only in one direction. In other words, we can say that each node contains only next pointer, therefore we can not traverse the list in the reverse direction. Consider an example where the marks obtained by the student in three subjects are stored in a linked list as shown in the figure. In the above figure, the arrow represents the links. The data part of every node contains the marks obtained by the student in the different subject. The last node in the list is identified by the null pointer which is present in the address part of the last node. We can have as many elements we require, in the data part of the list. ComplexityOperations on Singly Linked ListThere are various operations which can be performed on singly linked list. A list of all such operations is given below.The insertion into a singly linked list can be performed at different positions. Based on the position of the new node being inserted, the insertion is categorized into the following categories.The Deletion of a node from a singly linked list can be performed at different positions. Based on the position of the node being deleted, the operation is categorized into the following categories.
Linked List in C: Menu Driven ProgramOutput:","We read the linear data structures like an array, linked list, stack and queue in which all the elements are arranged in a sequential manner. The different data structures are used for different kinds of data.Some factors are considered for choosing the data structure:
What type of data needs to be stored?: It might be a possibility that a certain data structure can be the best fit for some kind of data.
Cost of operations: If we want to minimize the cost for the operations for the most frequently performed operations. For example, we have a simple list on which we have to perform the search operation; then, we can create an array in which elements are stored in sorted order to perform the binary search. The binary search works very fast for the simple list as it divides the search space into half.
Memory usage: Sometimes, we want a data structure that utilizes less memory.
A tree is also one of the data structures that represent hierarchical data. Suppose we want to show the employees and their positions in the hierarchical form then it can be represented as shown below:The above tree shows the organization hierarchy of some company. In the above structure, john is the CEO of the company, and John has two direct reports named as Steve and Rohan. Steve has three direct reports named Lee, Bob, Ella where Steve is a manager. Bob has two direct reports named Sal and Emma. Emma has two direct reports named Tom and Raj. Tom has one direct report named Bill. This particular logical structure is known as a Tree. Its structure is similar to the real tree, so it is named a Tree. In this structure, the root is at the top, and its branches are moving in a downward direction. Therefore, we can say that the Tree data structure is an efficient way of storing the data in a hierarchical way.Let's understand some key points of the Tree data structure.
A tree data structure is defined as a collection of objects or entities known as nodes that are linked together to represent or simulate hierarchy.
A tree data structure is a non-linear data structure because it does not store in a sequential manner. It is a hierarchical structure as elements in a Tree are arranged in multiple levels.
In the Tree data structure, the topmost node is known as a root node. Each node contains some data, and data can be of any type. In the above tree structure, the node contains the name of the employee, so the type of data would be a string.
Each node contains some data and the link or reference of other nodes that can be called children.
Some basic terms used in Tree data structure.Let's consider the tree structure, which is shown below:In the above structure, each node is labeled with some number. Each arrow shown in the above figure is known as a link between the two nodes.
Root: The root node is the topmost node in the tree hierarchy. In other words, the root node is the one that doesn't have any parent. In the above structure, node numbered 1 is the root node of the tree. If a node is directly linked to some other node, it would be called a parent-child relationship.
Child node: If the node is a descendant of any node, then the node is known as a child node.
Parent: If the node contains any sub-node, then that node is said to be the parent of that sub-node.
Sibling: The nodes that have the same parent are known as siblings.
Leaf Node:- The node of the tree, which doesn't have any child node, is called a leaf node. A leaf node is the bottom-most node of the tree. There can be any number of leaf nodes present in a general tree. Leaf nodes can also be called external nodes.
Internal nodes: A node has atleast one child node known as an internal
Ancestor node:- An ancestor of a node is any predecessor node on a path from the root to that node. The root node doesn't have any ancestors. In the tree shown in the above image, nodes 1, 2, and 5 are the ancestors of node 10.
Descendant: The immediate successor of the given node is known as a descendant of a node. In the above figure, 10 is the descendant of node 5.

Recursive data structure: The tree is also known as a recursive data structure. A tree can be defined as recursively because the distinguished node in a tree data structure is known as a root node. The root node of the tree contains a link to all the roots of its subtrees. The left subtree is shown in the yellow color in the below figure, and the right subtree is shown in the red color. The left subtree can be further split into subtrees shown in three different colors. Recursion means reducing something in a self-similar manner. So, this recursive property of the tree data structure is implemented in various applications.

Number of edges: If there are n nodes, then there would n-1 edges. Each arrow in the structure represents the link or path. Each node, except the root node, will have atleast one incoming link known as an edge. There would be one link for the parent-child relationship.
Depth of node x: The depth of node x can be defined as the length of the path from the root to the node x. One edge contributes one-unit length in the path. So, the depth of node x can also be defined as the number of edges between the root node and the node x. The root node has 0 depth.
Height of node x: The height of node x can be defined as the longest path from the node x to the leaf node.
Based on the properties of the Tree data structure, trees are classified into various categories.The tree data structure can be created by creating the nodes dynamically with the help of the pointers. The tree in the memory can be represented as shown below:The above figure shows the representation of the tree data structure in the memory. In the above structure, the node contains three fields. The second field stores the data; the first field stores the address of the left child, and the third field stores the address of the right child.In programming, the structure of a node can be defined as:The above structure can only be defined for the binary trees because the binary tree can have utmost two children, and generic trees can have more than two children. The structure of the node for generic trees would be different as compared to the binary tree.The following are the applications of trees:
Storing naturally hierarchical data: Trees are used to store the data in the hierarchical structure. For example, the file system. The file system stored on the disc drive, the file and folder are in the form of the naturally hierarchical data and stored in the form of trees.
Organize data: It is used to organize data for efficient insertion, deletion and searching. For example, a binary tree has a logN time for searching an element.
Trie: It is a special kind of tree that is used to store the dictionary. It is a fast and efficient way for dynamic spell checking.
Heap: It is also a tree data structure implemented using arrays. It is used to implement priority queues.
B-Tree and B+Tree: B-Tree and B+Tree are the tree data structures used to implement indexing in databases.
Routing table: The tree data structure is also used to store the data in routing tables in the routers.
The following are the types of a tree data structure:
General tree: The general tree is one of the types of tree data structure. In the general tree, a node can have either 0 or maximum n number of nodes. There is no restriction imposed on the degree of the node (the number of nodes that a node can contain). The topmost node in a general tree is known as a root node. The children of the parent node are known as subtrees.

There can be n number of subtrees in a general tree. In the general tree, the subtrees are unordered as the nodes in the subtree cannot be ordered.
Every non-empty tree has a downward edge, and these edges are connected to the nodes known as child nodes. The root node is labeled with level 0. The nodes that have the same parent are known as siblings.
Binary tree: Here, binary name itself suggests two numbers, i.e., 0 and 1. In a binary tree, each node in a tree can have utmost two child nodes. Here, utmost means whether the node has 0 nodes, 1 node or 2 nodes.

To know more about the binary tree, click on the link given below:
https://www.javatpoint.com/binary-tree
Binary Search tree: Binary search tree is a non-linear data structure in which one node is connected to n number of nodes. It is a node-based data structure. A node can be represented in a binary search tree with three fields, i.e., data part, left-child, and right-child. A node can be connected to the utmost two child nodes in a binary search tree, so the node contains two pointers (left child and right child pointer).
Every node in the left subtree must contain a value less than the value of the root node, and the value of each node in the right subtree must be bigger than the value of the root node.
A node can be created with the help of a user-defined data type known as struct, as shown below:The above is the node structure with three fields: data field, the second field is the left pointer of the node type, and the third field is the right pointer of the node type.To know more about the binary search tree, click on the link given below:https://www.javatpoint.com/binary-search-tree
AVL tree
It is one of the types of the binary tree, or we can say that it is a variant of the binary search tree. AVL tree satisfies the property of the binary tree as well as of the binary search tree. It is a self-balancing binary search tree that was invented by Adelson Velsky Lindas. Here, self-balancing means that balancing the heights of left subtree and right subtree. This balancing is measured in terms of the balancing factor.We can consider a tree as an AVL tree if the tree obeys the binary search tree as well as a balancing factor. The balancing factor can be defined as the difference between the height of the left subtree and the height of the right subtree. The balancing factor's value must be either 0, -1, or 1; therefore, each node in the AVL tree should have the value of the balancing factor either as 0, -1, or 1.To know more about the AVL tree, click on the link given below:https://www.javatpoint.com/avl-tree
Red-Black Tree
The red-Black tree is the binary search tree. The prerequisite of the Red-Black tree is that we should know about the binary search tree. In a binary search tree, the value of the left-subtree should be less than the value of that node, and the value of the right-subtree should be greater than the value of that node. As we know that the time complexity of binary search in the average case is log2n, the best case is O(1), and the worst case is O(n).When any operation is performed on the tree, we want our tree to be balanced so that all the operations like searching, insertion, deletion, etc., take less time, and all these operations will have the time complexity of log2n.The red-black tree is a self-balancing binary search tree. AVL tree is also a height balancing binary search tree then why do we require a Red-Black tree. In the AVL tree, we do not know how many rotations would be required to balance the tree, but in the Red-black tree, a maximum of 2 rotations are required to balance the tree. It contains one extra bit that represents either the red or black color of a node to ensure the balancing of the tree.
Splay tree
The splay tree data structure is also binary search tree in which recently accessed element is placed at the root position of tree by performing some rotation operations. Here, splaying means the recently accessed node. It is a self-balancing binary search tree having no explicit balance condition like AVL tree.It might be a possibility that height of the splay tree is not balanced, i.e., height of both left and right subtrees may differ, but the operations in splay tree takes order of logN time where n is the number of nodes.Splay tree is a balanced tree but it cannot be considered as a height balanced tree because after each operation, rotation is performed which leads to a balanced tree.
Treap
Treap data structure came from the Tree and Heap data structure. So, it comprises the properties of both Tree and Heap data structures. In Binary search tree, each node on the left subtree must be equal or less than the value of the root node and each node on the right subtree must be equal or greater than the value of the root node. In heap data structure, both right and left subtrees contain larger keys than the root; therefore, we can say that the root node contains the lowest value.In treap data structure, each node has both key and priority where key is derived from the Binary search tree and priority is derived from the heap data structure.The Treap data structure follows two properties which are given below:
Right child of a node>=current node and left child of a node <=current node (binary tree)
Children of any subtree must be greater than the node (heap)

B-tree
B-tree is a balanced m-way tree where m defines the order of the tree. Till now, we read that the node contains only one key but b-tree can have more than one key, and more than 2 children. It always maintains the sorted data. In binary tree, it is possible that leaf nodes can be at different levels, but in b-tree, all the leaf nodes must be at the same level.If order is m then node has the following properties:
Each node in a b-tree can have maximum m children
For minimum children, a leaf node has 0 children, root node has minimum 2 children and internal node has minimum ceiling of m/2 children. For example, the value of m is 5 which means that a node can have 5 children and internal nodes can contain maximum 3 children.
Each node has maximum (m-1) keys.
The root node must contain minimum 1 key and all other nodes must contain atleast ceiling of m/2 minus 1 keys.","A graph can be defined as group of vertices and edges that are used to connect these vertices. A graph can be seen as a cyclic tree, where the vertices (Nodes) maintain any complex relationship among them instead of having parent child relationship.DefinitionA graph G can be defined as an ordered set G(V, E) where V(G) represents the set of vertices and E(G) represents the set of edges which are used to connect these vertices.A Graph G(V, E) with 5 vertices (A, B, C, D, E) and six edges ((A,B), (B,C), (C,E), (E,D), (D,B), (D,A)) is shown in the following figure.Directed and Undirected GraphA graph can be directed or undirected. However, in an undirected graph, edges are not associated with the directions with them. An undirected graph is shown in the above figure since its edges are not attached with any of the directions. If an edge exists between vertex A and B then the vertices can be traversed from B to A as well as A to B.In a directed graph, edges form an ordered pair. Edges represent a specific path from some vertex A to another vertex B. Node A is called initial node while node B is called terminal node.A directed graph is shown in the following figure.Graph TerminologyA path can be defined as the sequence of nodes that are followed in order to reach some terminal node V from the initial node U.A path will be called as closed path if the initial node is same as terminal node. A path will be closed path if V0=VN.If all the nodes of the graph are distinct with an exception V0=VN, then such path P is called as closed simple path.A cycle can be defined as the path which has no repeated edges or vertices except the first and last vertices.A connected graph is the one in which some path exists between every two vertices (u, v) in V. There are no isolated nodes in connected graph.A complete graph is the one in which every node is connected with all other nodes. A complete graph contain n(n-1)/2 edges where n is the number of nodes in the graph.In a weighted graph, each edge is assigned with some data such as length or weight. The weight of an edge e can be given as w(e) which must be a positive (+) value indicating the cost of traversing the edge.A digraph is a directed graph in which each edge of the graph is associated with some direction and the traversing can be done only in the specified direction.An edge that is associated with the similar end points can be called as Loop.If two nodes u and v are connected via an edge e, then the nodes u and v are called as neighbours or adjacent nodes.A degree of a node is the number of edges that are connected with that node. A node with degree 0 is called as isolated node.","Assume we want to create a system for storing employee records that include phone numbers (as keys). We also want the following queries to run quickly:
Insert a phone number and any necessary information.
Look up a phone number and get the information.
Remove a phone number and any associated information.
We can consider using the following data structures to store information about various phone numbers.
A collection of phone numbers and records.
Phone numbers and records are linked in this list.
Phone numbers serve as keys in a balanced binary search tree.
Table with Direct Access.
We must search in a linear fashion for arrays and linked lists, which can be costly in practise. If we use arrays and keep the data sorted, we can use Binary Search to find a phone number in O(Logn) time, but insert and delete operations become expensive because we must keep the data sorted.We get moderate search, insert, and delete times with a balanced binary search tree. All of these operations will be completed in O(Logn) time.The term ""access-list"" refers to a set of rules for controlling network traffic and reducing network attacks. ACLs are used to filter network traffic based on a set of rules defined for incoming or outgoing traffic.Another option is to use a direct access table, in which we create a large array and use phone numbers as indexes. If the phone number is not present, the array entry is NIL; otherwise, the array entry stores a pointer to the records corresponding to the phone number. In terms of time complexity, this solution is the best of the bunch; we can perform all operations in O(1) time. To insert a phone number, for example, we create a record with the phone number's details, use the phone number as an index, and store the pointer to the newly created record in the table.This solution has a number of practical drawbacks. The first issue with this solution is the amount of extra space required. For example, if a phone number has n digits, we require O(m * 10n) table space, where m is the size of a pointer to record. Another issue is that an integer in a programming language cannot hold n digits.Because of the limitations mentioned above, Direct Access Table cannot always be used. In practise, Hashing is the solution that can be used in almost all such situations and outperforms the above data structures such as Array, Linked List, and Balanced BST. We get O(1) search time on average (under reasonable assumptions) and O(n) in the worst case with hashing. Let's break down what hashing is.What exactly do you mean by hashing?Hashing is a popular technique for quickly storing and retrieving data. The primary reason for using hashing is that it produces optimal results by performing optimal searches.Why should you use Hashing?If we try to search, insert, or delete any element in a balanced binary search tree, the time complexity for the same is O. (logn). Now, there may be times when our applications need to perform the same operations in a faster, more optimised manner, and this is where hashing comes into play. All of the above operations in hashing can be completed in O(1), or constant time. It is critical to understand that hashing's worst-case time complexity remains O(n), but its average time complexity is O. (1).Let us now look at some fundamental hashing operations.Fundamental Operations:
HashTable: Use this operation to create a new hash table.
Delete: This operation is used to remove a specific key-value pair from the hash table.
Get: This operation is used to find a key within the hash table and return the value associated with that key.
Put: This operation is used to add a new key-value pair to the hash table.
DeleteHashTable: This operation is used to remove the hash table.
Describe the hash function.
A hash function is a fixed procedure that changes a key into a hash key.
This function converts a key into a length-restricted value known as a hash value or hash.
Although the hash value is typically less than the original, it nevertheless represents the original string of characters.
The digital signature is transferred, and both the hash value and the signature are then given to the recipient. The hash value generated by the receiver using the same hash algorithm is compared to the hash value received along with the message.
The message is sent without problems if the hash values match.
Hash Table: What is it?
A data structure called a hash table or hash map is used to hold key-value pairs.
It is a collection of materials that have been organised for later simple access.
It computes an index into an array of buckets or slots from which the requested value can be located using a hash function.
Each list in the array is referred to as a bucket.
On the basis of the key, it contains value.
The map interface is implemented using a hash table, which also extends the Dictionary class.
The hash table is synchronised and only has distinct components.
Components of Hashing:
Hash Table: An array that stores pointers to records that correspond to a specific phone number. If no existing phone number has a hash function value equal to the index for the entry, the entry in the hash table is NIL. In simple terms, a hash table is a generalisation of an array. A hash table provides the functionality of storing a collection of data in such a way that it is easy to find those items later if needed. This makes element searching very efficient.
Hash Function: A function that reduces a large phone number to a small practical integer value. In a hash table, the mapped integer value serves as an index. So, to put it simply, a hash function is used to convert a given key into a specific slot index. Its primary function is to map every possible key to a unique slot index. The hash function is referred to as a perfect hash function if each key maps to a distinct slot index. Although it is exceedingly challenging to construct the ideal hash function, it is our responsibility as programmers to do so in a way that minimises the likelihood of collisions. This section will cover collision.
The following characteristics a decent hash function ought to have:
Effectively calculable.
The keys ought to be distributed equally among all table positions.
Ought to reduce collisions.
Low load factor should be the norm (number of items in table divided by size of the table).
A poor hash function for phone numbers, for instance, would be to use the first three digits. Consideration of the last three numbers is a better function. Please be aware that this hash function might not be the best. There could be better options.
Handling Collisions: Because a hash function only returns a little number for a large key, it is possible that two keys will yield the same result. Collision occurs when a newly added key corresponds to a hash table slot that is already taken, and it needs to be handled using a collision handling mechanism. The methods for handling collisions are as follows:

Making each hash table cell point to a linked list of records with the same hash function value is known as ""chaining."" Although chaining is straightforward, more memory is needed outside of the table.
Open Addressing: In open addressing, the hash table itself serves as the storage location for all items. Either a record or NIL is present in every table entry. When looking for an element, we look through each table slot individually until the sought-after element is discovered or it becomes obvious that the element is not in the table.


In data structures, hashing produces array indexes that are already used to store a value. In this situation, hashing does a search operation and linearly probes for the subsequent empty cell.The simplest method for handling collisions in hash tables is known as linear probing in hash algorithms. Any collision that occurred can be located using a sequential search.Two hash functions are used in the double hashing method. When the first hash function results in a collision, the second hash function is used. In order to store the value, it offers an offset index.The double hashing method's formula is as follows:(firstHash(key) + i * secondHash(key)) % sizeOfTableThe offset value is represented by i. The offset value is continuously increased until it encounters an empty slot.","A heap is a complete binary tree, and the binary tree is a tree in which the node can have utmost two children. Before knowing more about the heap data structure, we should know about the complete binary tree.A complete binary tree is a binary tree in which all the levels except the last level, i.e., leaf node should be completely filled, and all the nodes should be left-justified.Let's understand through an example.In the above figure, we can observe that all the internal nodes are completely filled except the leaf node; therefore, we can say that the above tree is a complete binary tree.The above figure shows that all the internal nodes are completely filled except the leaf node, but the leaf nodes are added at the right part; therefore, the above tree is not a complete binary tree.There are two types of the heap:
Min Heap
Max heap
Min Heap: The value of the parent node should be less than or equal to either of its children.OrIn other words, the min-heap can be defined as, for every node i, the value of node i is greater than or equal to its parent value except the root node. Mathematically, it can be defined as:A[Parent(i)] <= A[i]Let's understand the min-heap through an example.In the above figure, 11 is the root node, and the value of the root node is less than the value of all the other nodes (left child or a right child).Max Heap: The value of the parent node is greater than or equal to its children.OrIn other words, the max heap can be defined as for every node i; the value of node i is less than or equal to its parent value except the root node. Mathematically, it can be defined as:A[Parent(i)] >= A[i]The above tree is a max heap tree as it satisfies the property of the max heap. Now, let's see the array representation of the max heap.Time complexity in Max HeapThe total number of comparisons required in the max heap is according to the height of the tree. The height of the complete binary tree is always logn; therefore, the time complexity would also be O(logn).Algorithm of insert operation in the max heap.Let's understand the max heap through an example.In the above figure, 55 is the parent node and it is greater than both of its child, and 11 is the parent of 9 and 8, so 11 is also greater than from both of its child. Therefore, we can say that the above tree is a max heap tree.Insertion in the Heap tree44, 33, 77, 11, 55, 88, 66Suppose we want to create the max heap tree. To create the max heap tree, we need to consider the following two cases:
First, we have to insert the element in such a way that the property of the complete binary tree must be maintained.
Secondly, the value of the parent node should be greater than the either of its child.
Step 1: First we add the 44 element in the tree as shown below:Step 2: The next element is 33. As we know that insertion in the binary tree always starts from the left side so 44 will be added at the left of 33 as shown below:Step 3: The next element is 77 and it will be added to the right of the 44 as shown below:As we can observe in the above tree that it does not satisfy the max heap property, i.e., parent node 44 is less than the child 77. So, we will swap these two values as shown below:Step 4: The next element is 11. The node 11 is added to the left of 33 as shown below:Step 5: The next element is 55. To make it a complete binary tree, we will add the node 55 to the right of 33 as shown below:As we can observe in the above figure that it does not satisfy the property of the max heap because 33<55, so we will swap these two values as shown below:Step 6: The next element is 88. The left subtree is completed so we will add 88 to the left of 44 as shown below:As we can observe in the above figure that it does not satisfy the property of the max heap because 44<88, so we will swap these two values as shown below:Again, it is violating the max heap property because 88>77 so we will swap these two values as shown below:Step 7: The next element is 66. To make a complete binary tree, we will add the 66 element to the right side of 77 as shown below:In the above figure, we can observe that the tree satisfies the property of max heap; therefore, it is a heap tree.Deletion in Heap TreeIn Deletion in the heap tree, the root node is always deleted and it is replaced with the last element.Let's understand the deletion through an example.Step 1: In the above tree, the first 30 node is deleted from the tree and it is replaced with the 15 element as shown below:Now we will heapify the tree. We will check whether the 15 is greater than either of its child or not. 15 is less than 20 so we will swap these two values as shown below:Again, we will compare 15 with its child. Since 15 is greater than 10 so no swapping will occur.Algorithm to heapify the tree"
